<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>CRACKED Orb // v1</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #000; /* Keep it dark */
            touch-action: none;
            cursor: crosshair; /* Enhance the vibe */
        }
        canvas {
            display: block;
        }
        #backButton {
            position: absolute;
            top: 15px; /* Slightly more space */
            left: 15px;
            color: rgba(200, 200, 200, 0.7); /* Subtler */
            font-size: 28px; /* Bigger */
            font-family: monospace; /* Techy feel */
            cursor: pointer;
            z-index: 1000;
            background: none;
            border: none;
            padding: 0;
            text-shadow: 0 0 5px rgba(150, 180, 255, 0.5); /* Subtle glow */
            transition: color 0.3s ease, text-shadow 0.3s ease;
        }
        #backButton:hover {
            color: rgba(255, 255, 255, 1);
            text-shadow: 0 0 10px rgba(180, 210, 255, 0.8);
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.min.js"></script>
</head>
<body>
    <button id="backButton" onclick="goBack()" aria-label="Go Back">&lt;</button>
    <script>
        // --- CRACKED Config ---
        const SPHERE_RADIUS = Math.min(window.innerWidth, window.innerHeight) * 0.3; // Scale radius
        const SPHERE_DETAIL = 20; // Slightly less detail for performance, more angular look
        const MOMENTUM_FRICTION = 0.97; // Slightly less friction, more drift
        const GRAVITY_PULL = 0.00008; // Stronger gravity/tilt effect
        const ACCEL_MULTIPLIER = 70; // Boost accelerometer influence
        const NOTCH_DISTANCE_DRAG = 10; // More frequent feedback on drag
        const NOTCH_DISTANCE_MOMENTUM = 12; // More frequent feedback on momentum
        const CHARGE_DECAY = 0.988; // Slower decay, stays charged longer
        const MAX_CHARGE = 100;
        const CHARGE_RATE_DRAG = 0.3; // Base charge rate from dragging
        const CHARGE_RATE_FAST_DRAG_MULT = 1.8; // Multiplier for fast drags
        const CHARGE_RATE_MOMENTUM = 10; // Charge rate from momentum speed
        const BIG_DISCHARGE_MIN_INTERVAL = 2000; // Can discharge more often
        const HEARTBEAT_RATE = 1.0; // Faster pulse
        const MAX_GLOW_BLUR = 40; // More intense glow
        const JITTER_INTENSITY = 0.005; // How much it jitters when charged
        const STAR_COUNT = 200; // Number of background stars

        // Haptic Feedback Durations (ms)
        const HAPTIC_CLICK = 5; // Sharper click
        const HAPTIC_MAJOR_DISCHARGE = 80; // Slightly longer major buzz

        // --- State Vars ---
        let rotX = 0;
        let rotY = 0;
        let prevMouseX, prevMouseY;
        let isDragging = false;
        let momX = 0, momY = 0;
        let wireframeSphere;
        let lastInteractionTime = 0;
        let distanceSinceLastNotch = 0;
        let chargeLevel = 0;
        let discharges = [];
        let intensityHistory = []; // Kept for discharge logic, could optimize later
        const INTENSITY_HISTORY_MAX = 15; // Shorter history needed
        let lastBigDischargeTime = 0;
        let heartbeatPulse = 0;
        let accelX = 0, accelY = 0;
        let isMobile = /Mobi|Android/i.test(navigator.userAgent);
        let stars = []; // For background starfield

        // --- Audio Vars ---
        let audioContext;
        let masterGain;

        // --- Setup ---
        function setup() {
            createCanvas(windowWidth, windowHeight, WEBGL);
            colorMode(HSB, 360, 100, 100, 100); // Use HSB for easier color manipulation
            noFill();
            strokeWeight(1.3); // Slightly thicker lines
            wireframeSphere = createWireframeSphere(SPHERE_RADIUS, SPHERE_DETAIL);
            generateStars();

            let canvas = document.querySelector('canvas');
            canvas.addEventListener('mousedown', handleMouseDown);
            document.addEventListener('mousemove', handleMouseMove);
            document.addEventListener('mouseup', handleMouseUp);
            canvas.addEventListener('touchstart', handleTouchStart, { passive: false });
            document.addEventListener('touchmove', handleTouchMove, { passive: false });
            document.addEventListener('touchend', handleTouchEnd);
            canvas.addEventListener('wheel', handleWheel, { passive: false });

            document.addEventListener('mousedown', initAudio, { once: true });
            document.addEventListener('touchstart', initAudio, { once: true });

            if (isMobile && window.DeviceMotionEvent) {
                window.addEventListener('devicemotion', handleDeviceMotion);
                // Give it a stronger initial kick on mobile
                momX = random(-0.015, 0.015);
                momY = random(-0.015, 0.015);
            } else {
                 // Initial kick for desktop too
                momX = random(-0.005, 0.005);
                momY = random(-0.005, 0.005);
            }
        }

        // --- Starfield ---
        function generateStars() {
            stars = [];
            for (let i = 0; i < STAR_COUNT; i++) {
                stars.push({
                    x: random(-width * 1.5, width * 1.5),
                    y: random(-height * 1.5, height * 1.5),
                    z: random(-max(width, height), max(width, height)),
                    size: random(1, 3)
                });
            }
        }

        function drawStars() {
            push();
            noStroke();
            // Apply subtle parallax based on rotation/momentum
            let parallaxX = momY * 500; // Inverted axis
            let parallaxY = momX * 500;
            translate(parallaxX, parallaxY, -500); // Move stars back

            for (let star of stars) {
                let alpha = map(star.z, -max(width, height), max(width, height), 10, 70);
                 // Twinkle effect
                let twinkle = noise(star.x * 0.1, star.y * 0.1, frameCount * 0.05) * 50 + 50;
                fill(200, 5, 100, alpha * (twinkle / 100)); // Use HSB, slightly blueish white
                push();
                translate(star.x, star.y, star.z);
                ellipse(0, 0, star.size, star.size);
                pop();
            }
            pop();
        }


        // --- Sphere Geometry Creation (Unchanged) ---
        function createWireframeSphere(r, detail) {
            // ... (same as original) ...
            let sphere = [];
            for (let i = 0; i < detail; i++) {
                let lon = map(i, 0, detail, 0, TWO_PI);
                let lonPoints = [];
                for (let j = 0; j <= detail; j++) {
                    let lat = map(j, 0, detail, 0, PI);
                    let x = r * sin(lat) * cos(lon);
                    let y = r * sin(lat) * sin(lon);
                    let z = r * cos(lat);
                    lonPoints.push(createVector(x, y, z));
                }
                sphere.push({ type: 'longitude', points: lonPoints });
            }
            for (let j = 1; j < detail; j++) {
                let lat = map(j, 0, detail, 0, PI);
                let latPoints = [];
                for (let i = 0; i <= detail; i++) {
                    let lon = map(i, 0, detail, 0, TWO_PI);
                    let x = r * sin(lat) * cos(lon);
                    let y = r * sin(lat) * sin(lon);
                    let z = r * cos(lat);
                    latPoints.push(createVector(x, y, z));
                }
                sphere.push({ type: 'latitude', points: latPoints });
            }
            return sphere;
        }


        // --- Main Draw Loop --- (Enhanced visuals)
        function draw() {
            background(0); // Black background
            drawStars(); // Draw background stars first

            heartbeatPulse = (sin(frameCount * 0.05 * HEARTBEAT_RATE) + 1) * 0.5; // Faster pulse calculation
            ambientLight(50); // Slightly brighter ambient
            pointLight(255, 100, 80, 200, -150, 250); // White point light

            handleMomentum();

            chargeLevel = max(0, chargeLevel * CHARGE_DECAY);

            // More frequent random static discharges based on charge
            if (chargeLevel > 10 && random() < 0.015 * (chargeLevel / MAX_CHARGE)) {
                 createStaticDischarge(0.6 + random(0.6)); // Slightly smaller base size, more variance
            }
            checkForMajorDischarge();

            push();

            // Apply jitter based on charge level
            let jitterX = (chargeLevel / MAX_CHARGE) * JITTER_INTENSITY * (noise(frameCount * 0.5) - 0.5);
            let jitterY = (chargeLevel / MAX_CHARGE) * JITTER_INTENSITY * (noise(frameCount * 0.5 + 100) - 0.5);

            // Apply rotation
            rotateX(rotY + jitterY);
            rotateY(rotX + jitterX);


            // Dynamic Glow based on charge
            let chargeRatio = chargeLevel / MAX_CHARGE;
            let glowIntensity = chargeRatio * MAX_GLOW_BLUR * (0.8 + heartbeatPulse * 0.4); // Pulsating glow
            let glowHue = map(chargeRatio, 0, 1, 200, 240); // Shift from cyan to blue
            let glowSaturation = 80 + chargeRatio * 20;
            let glowBrightness = 90 + chargeRatio * 10;
            let glowAlpha = map(chargeRatio, 0, 1, 10, 60) * (0.8 + heartbeatPulse * 0.4); // Pulsating alpha

            drawingContext.shadowBlur = glowIntensity;
            drawingContext.shadowColor = `hsla(${glowHue}, ${glowSaturation}%, ${glowBrightness}%, ${glowAlpha / 100})`;

            drawWireframeSphere(chargeRatio);
            updateAndDrawDischarges();

            drawingContext.shadowBlur = 0; // Reset shadow for other elements if any
            pop();
        }

        // --- Momentum Handling --- (Boosted effects)
        function handleMomentum() {
            if (!isDragging) {
                // Apply accelerometer-based grounding (Boosted)
                if (isMobile) {
                    momX += accelY * GRAVITY_PULL * ACCEL_MULTIPLIER; // Invert Y-axis for natural tilt
                    momY += accelX * GRAVITY_PULL * ACCEL_MULTIPLIER; // X-axis tilt
                } else {
                     // Keep desktop gravity subtle but present
                    momY += GRAVITY_PULL;
                }

                // Apply momentum to rotation angles
                rotX += momX;
                rotY += momY;

                // Apply friction
                momX *= MOMENTUM_FRICTION;
                momY *= MOMENTUM_FRICTION;

                // Trigger sound/haptics/charge based on movement speed
                let movement = sqrt(momX * momX + momY * momY);
                distanceSinceLastNotch += movement * SPHERE_RADIUS * 0.8; // Scale notch distance by radius somewhat

                // More aggressive charge from momentum
                let chargeAddMomentum = constrain(movement * CHARGE_RATE_MOMENTUM, 0, 2.0);
                chargeLevel = min(MAX_CHARGE, chargeLevel + chargeAddMomentum);

                if (distanceSinceLastNotch > NOTCH_DISTANCE_MOMENTUM) {
                    let intensity = constrain(movement * 200, 0.05, 0.8); // Scale intensity calc
                    playClickSound(intensity * 1.2); // Slightly louder momentum clicks
                    updateIntensityHistory(intensity);

                    // Higher chance of static discharge from momentum
                    let staticProb = map(chargeLevel, 0, MAX_CHARGE, 0.15, 0.5) * map(intensity, 0.05, 0.8, 0.6, 1.4);
                    if (random() < staticProb) {
                        createStaticDischarge();
                    }
                    distanceSinceLastNotch = 0;
                }
            } else { // If dragging, slowly fade intensity history
                 if (intensityHistory.length > 0 && frameCount % 8 === 0) { // Faster fade
                    intensityHistory.shift();
                }
            }
        }

        // --- Device Motion Handling --- (Increased sensitivity check)
        function handleDeviceMotion(event) {
            if (event.accelerationIncludingGravity) {
                accelX = event.accelerationIncludingGravity.x / 10;
                accelY = event.accelerationIncludingGravity.y / 10;

                // Trigger haptics on slightly smaller motion
                if (Math.abs(accelX) > 0.3 || Math.abs(accelY) > 0.3) {
                    // Throttle haptic triggers from accelerometer to avoid constant buzz
                    if (frameCount % 5 === 0) {
                       triggerHaptic('click');
                    }
                }
            }
        }

        // --- Drawing Functions ---
        function drawWireframeSphere(chargeRatio) {
            // Dynamic HSB Color based on charge and pulse
            let baseHue = 190; // Teal/Cyan base
            let targetHue = 240; // Blue target
            let currentHue = lerp(baseHue, targetHue, chargeRatio * chargeRatio); // Faster shift towards blue

            let baseSat = 50;
            let targetSat = 90;
            let currentSat = lerp(baseSat, targetSat, chargeRatio);

            let baseBright = 60 + heartbeatPulse * 20; // Pulsating brightness base
            let targetBright = 95;
            let currentBright = lerp(baseBright, targetBright, chargeRatio);

            let baseAlpha = 60;
            let targetAlpha = 95;
            let currentAlpha = lerp(baseAlpha, targetAlpha, chargeRatio) + heartbeatPulse * 5;

            for (let line of wireframeSphere) {
                beginShape();
                for (let v of line.points) {
                    // Add slight vertex displacement based on charge for instability effect
                    let displaceMag = chargeRatio * chargeRatio * 1.5 * noise(v.x * 0.1, v.y*0.1, v.z*0.1 + frameCount * 0.05);
                    let displacedV = p5.Vector.add(v, p5.Vector.random3D().mult(displaceMag));

                    stroke(currentHue, currentSat, currentBright, currentAlpha);
                    vertex(displacedV.x, displacedV.y, displacedV.z);
                }
                // Connect last to first for latitude lines
                if (line.type === 'latitude' && line.points.length > 0) {
                     let first = line.points[0];
                     let displaceMag = chargeRatio * chargeRatio * 1.5 * noise(first.x * 0.1, first.y*0.1, first.z*0.1 + frameCount * 0.05);
                     let displacedV = p5.Vector.add(first, p5.Vector.random3D().mult(displaceMag));
                     vertex(displacedV.x, displacedV.y, displacedV.z);
                }
                endShape();
            }
        }
        // --- Update/Draw Discharges (Minor visual tweaks maybe) ---
        function updateAndDrawDischarges() {
            // ... (mostly same as original) ...
             for (let i = discharges.length - 1; i >= 0; i--) {
                let d = discharges[i];
                d.life--;
                if (d.life <= 0) {
                    discharges.splice(i, 1);
                    continue;
                }
                if (d.type === 'static') {
                    drawStaticDischarge(d);
                } else if (d.type === 'major') {
                    drawMajorDischarge(d);
                }
            }
        }
        function drawStaticDischarge(d) {
            let lifeRatio = d.life / d.maxLife;
            let flicker = 0.7 + 0.4 * noise(frameCount * 0.4 + d.variation * 10); // More flicker
            let alpha = map(sqrt(lifeRatio), 0, 1, 0, 80) * flicker; // HSB alpha range 0-100
            strokeWeight(d.weight * 1.1); // Slightly thicker static
            // Color (using HSB) - More electric blue/violet
            stroke(250 + flicker * 20, 80 + flicker * 15, 100, alpha);
            for (let seg of d.segments) {
                line(seg.p1.x, seg.p1.y, seg.p1.z, seg.p2.x, seg.p2.y, seg.p2.z);
            }
        }
         function drawMajorDischarge(d) {
            let lifeRatio = d.life / d.maxLife;
            let coreAlpha, glowAlpha, glowBlur;

            // Intense flash phase
            if (lifeRatio > 0.7) {
                let flashRatio = map(lifeRatio, 1.0, 0.7, 0, 1);
                coreAlpha = 100; // Full bright HSB
                glowAlpha = 80 + 20 * flashRatio; // Intense glow alpha
                glowBlur = 20 + 30 * (1 - flashRatio); // Wider glow initially
            } else { // Fade out phase
                coreAlpha = map(lifeRatio, 0, 0.7, 0, 100);
                glowAlpha = map(lifeRatio, 0, 0.7, 0, 80);
                glowBlur = map(lifeRatio, 0, 0.7, 5, 25); // Shrink glow as it fades
            }

            let time = frameCount * 0.15 + d.variation * 50; // Faster flicker time
            let flicker = 0.5 + 0.6 * noise(time * 3.5) * noise(time * 0.9 + 100); // More extreme flicker
            coreAlpha *= flicker;
            glowAlpha *= flicker * 0.8; // Glow alpha also flickers, slightly less

            // Core Color (HSB - Bright White/Violet)
            let coreHue = 270 + flicker * 20;
            let coreSat = 30 + flicker * 30;
            let coreBright = 100;

            // Apply glow via shadow context for branches
            drawingContext.shadowBlur = glowBlur;
            drawingContext.shadowColor = `hsla(${coreHue}, ${coreSat + 20}%, ${coreBright}%, ${glowAlpha / 100})`;

            drawLightningBranch(d.mainBranch, coreHue, coreSat, coreBright, coreAlpha);
            for (let branch of d.secondaryBranches) {
                 drawLightningBranch(branch, coreHue, coreSat, coreBright, coreAlpha * 0.8); // Secondary slightly dimmer
            }

             drawingContext.shadowBlur = 0; // Reset shadow IMPORTANTLY here
         }
         // Removed redundant glow drawing from branch, handled by shadowBlur now
         function drawLightningBranch(branch, hue, sat, bright, coreAlpha) {
             for (let seg of branch.segments) {
                 // Draw only the core bright line
                 strokeWeight(seg.width * 1.1); // Slightly thicker core
                 stroke(hue, sat, bright, coreAlpha);
                 line(seg.p1.x, seg.p1.y, seg.p1.z, seg.p2.x, seg.p2.y, seg.p2.z);
            }
         }


        // --- Intensity Tracking (Unchanged Logic) ---
        function updateIntensityHistory(intensity) { /* ... same ... */
             intensityHistory.push(intensity);
            if (intensityHistory.length > INTENSITY_HISTORY_MAX) {
                intensityHistory.shift();
            }
        }
        function getAverageIntensity() { /* ... same ... */
             if (intensityHistory.length < 3) return 0; // Need fewer samples
            let sum = intensityHistory.reduce((a, b) => a + b, 0);
            return sum / intensityHistory.length;
        }

        // --- Discharge Creation Logic ---
        function checkForMajorDischarge() {
            let now = millis();
            let avgIntensity = getAverageIntensity();
            // Lower threshold for intensity, higher random chance
            if (chargeLevel > 70 && // Slightly lower charge req
                now - lastBigDischargeTime > BIG_DISCHARGE_MIN_INTERVAL &&
                avgIntensity > 0.45 && // Lower intensity threshold
                random() < 0.08) { // Higher base chance
                 createMajorDischarge();
                 playMajorDischargeSound();
                 lastBigDischargeTime = now;
                 chargeLevel *= 0.4; // Drain more charge
                 intensityHistory = []; // Reset intensity faster
            }
        }
        function createStaticDischarge(sizeMultiplier = 1) {
            // ... (mostly same, maybe slightly longer length range) ...
             let phi = random(TWO_PI);
             let theta = acos(random(-1, 1));
             let start = p5.Vector.fromAngles(theta, phi, SPHERE_RADIUS);
             let dirOut = start.copy().normalize();
             // Slightly increased length variance
             let length = random(10, 25) * map(chargeLevel, 0, MAX_CHARGE, 0.7, 1.4) * sizeMultiplier;
             let numSegments = floor(random(2, 6)); // More segments possible
             let segments = [];
             let currentPoint = start.copy();
             let overallDir = p5.Vector.add(dirOut, p5.Vector.random3D().mult(0.6)).normalize(); // More deviation allowed
            for (let i = 0; i < numSegments; i++) {
                 let segmentLength = length / numSegments * random(0.7, 1.3); // More length variance per segment
                 let deviation = p5.Vector.random3D().mult(segmentLength * 0.5 * sin(map(i, 0, numSegments, 0, PI))); // More deviation
                 let nextPoint = p5.Vector.add(currentPoint, p5.Vector.add(overallDir.copy().mult(segmentLength), deviation));
                 segments.push({ p1: currentPoint.copy(), p2: nextPoint.copy() });
                 currentPoint = nextPoint;
             }
             let lifetime = 10 + random(10); // Slightly longer lifespan avg
             discharges.push({
                 type: 'static', segments: segments, life: lifetime, maxLife: lifetime,
                 variation: random(1000), weight: random(0.7, 1.4) // Wider weight variance
            });
        }
        function createMajorDischarge() {
            // ... (mostly same, maybe longer/more branches) ...
              let phi = random(TWO_PI);
             let theta = acos(random(-1, 1));
             let start = p5.Vector.fromAngles(theta, phi, SPHERE_RADIUS);
             let dirOut = start.copy().normalize();
             let mainLength = random(60, 120) * map(chargeLevel, 50, MAX_CHARGE, 0.8, 1.6); // Longer potential
             let mainIntensity = 1.0 + random(0.2); // Slightly variable intensity
             let mainBranch = createLightningBranch(start, dirOut, mainLength, mainIntensity);
             let secondaryBranches = [];
             let numSecondary = floor(random(3, 7)); // More secondary branches
             for (let i = 0; i < numSecondary; i++) {
                 let forkIndex = floor(pow(random(), 1.4) * (mainBranch.segments.length - 2)) + 1; // Slightly different distribution
                 if (forkIndex >= mainBranch.segments.length) forkIndex = mainBranch.segments.length -1; // Bounds check
                 if (forkIndex < 0) forkIndex = 0;
                 let forkSegment = mainBranch.segments[forkIndex];
                 let forkPoint = p5.Vector.lerp(forkSegment.p1, forkSegment.p2, random(0.1, 0.9)); // Wider fork range
                 let mainSegDir = p5.Vector.sub(forkSegment.p2, forkSegment.p1).normalize();
                 let forkDir = p5.Vector.random3D().cross(mainSegDir).normalize();
                 forkDir.lerp(dirOut, 0.3); // Less bias towards outward dir
                 forkDir.rotate(random(-0.7, 0.7)); // More angular variance
                 let branchLength = mainLength * random(0.25, 0.6) * (1 - forkIndex / mainBranch.segments.length); // Longer secondary avg
                 let branchIntensity = mainIntensity * random(0.4, 0.9); // Wider secondary intensity
                 secondaryBranches.push(createLightningBranch(forkPoint, forkDir, branchLength, branchIntensity));
             }
             let lifetime = 25 + random(20); // Longer major discharge lifetime
             discharges.push({
                 type: 'major', mainBranch: mainBranch, secondaryBranches: secondaryBranches,
                 life: lifetime, maxLife: lifetime, variation: random(1000)
             });
        }
        function createLightningBranch(start, direction, length, intensity) {
            // ... (mostly same, maybe tweak width) ...
             let segments = [];
            let numSegments = max(4, floor(length / 7) + floor(random(0, 5))); // More segments
            let currentPoint = start.copy();
            let targetEnd = p5.Vector.add(start, direction.copy().setMag(length));
            let baseWidth = 1.8 + intensity * 1.8; // Thicker base width
            for (let i = 1; i <= numSegments; i++) {
                 let t = i / numSegments;
                 let targetPoint = p5.Vector.lerp(start, targetEnd, t);
                 let deviationScale = length * 0.09 * sin(t * PI) * random(0.6, 1.4); // More deviation
                 let deviation = p5.Vector.random3D().setMag(deviationScale);
                 targetPoint.add(deviation);
                 let width = baseWidth * (1 - pow(t, 1.4)) + 0.4; // Width tapers slightly differently
                 segments.push({ p1: currentPoint.copy(), p2: targetPoint.copy(), width: width });
                 currentPoint = targetPoint;
            }
             return { segments: segments, intensity: intensity };
        }

        // --- Simplified Audio --- (CRACKED Sounds)
        async function initAudio() { /* ... same ... */
            if (!audioContext) {
                try {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    await audioContext.resume();
                    masterGain = audioContext.createGain();
                    masterGain.gain.value = 0.7; // Slightly louder master
                    masterGain.connect(audioContext.destination);
                } catch (e) {
                    console.error("Web Audio API could not start.", e);
                    audioContext = null;
                }
            }
        }

        function playClickSound(intensity = 0.5) {
            triggerHaptic('click');
            if (!audioContext || !masterGain) return;

            const osc = audioContext.createOscillator();
            const gain = audioContext.createGain();
            const now = audioContext.currentTime;

            let chargeFactor = chargeLevel / MAX_CHARGE;
            let baseFreq = 800 + chargeFactor * 400; // Higher base frequency
            let freq = baseFreq + random(-150, 150) * intensity; // Wider freq range based on intensity
            osc.frequency.setValueAtTime(freq, now);
            osc.frequency.exponentialRampToValueAtTime(freq * 0.6, now + 0.03); // Pitch drop
            osc.type = 'square'; // Sharper 'square' or 'sawtooth' wave

            let peakVol = 0.06 * intensity * (1 + chargeFactor * 0.8); // Slightly louder, more charge influence
            gain.gain.setValueAtTime(0, now);
            gain.gain.linearRampToValueAtTime(peakVol, now + 0.002); // Faster attack
            gain.gain.exponentialRampToValueAtTime(0.001, now + 0.03); // Sharper exponential decay

            osc.connect(gain);
            gain.connect(masterGain);
            osc.start(now);
            osc.stop(now + 0.035);
        }

        function playMajorDischargeSound() {
            triggerHaptic('major');
            if (!audioContext || !masterGain) return;
            const now = audioContext.currentTime;

            // Low frequency burst (more intense)
            const osc = audioContext.createOscillator();
            const gain = audioContext.createGain();
            osc.type = 'sawtooth'; // Harsher sawtooth wave
            let startFreq = 90 + random(-15, 15);
            osc.frequency.setValueAtTime(startFreq, now);
            osc.frequency.exponentialRampToValueAtTime(startFreq * 0.5, now + 0.18); // Deeper drop

            let peakVol = 0.35; // Louder!
            gain.gain.setValueAtTime(0, now);
            gain.gain.linearRampToValueAtTime(peakVol, now + 0.008); // Slightly faster attack
            gain.gain.exponentialRampToValueAtTime(0.01, now + 0.2); // Longer, harsher decay

            osc.connect(gain);
            gain.connect(masterGain);
            osc.start(now);
            osc.stop(now + 0.2);

            // More intense noise burst
            const noiseSource = audioContext.createBufferSource();
            const noiseGain = audioContext.createGain();
            const bufferSize = audioContext.sampleRate * 0.1; // Longer noise duration
            const noiseBuffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
            const output = noiseBuffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) { output[i] = Math.random() * 2 - 1; }
            noiseSource.buffer = noiseBuffer;

            noiseGain.gain.setValueAtTime(0, now);
            noiseGain.gain.linearRampToValueAtTime(0.25, now + 0.005); // Louder noise peak
            noiseGain.gain.exponentialRampToValueAtTime(0.001, now + 0.12); // Longer noise decay

            // Add a bandpass filter to the noise for more 'crack'
            const noiseFilter = audioContext.createBiquadFilter();
            noiseFilter.type = "bandpass";
            noiseFilter.frequency.setValueAtTime(1500 + random(-500, 500), now); // Center frequency for crackle
            noiseFilter.Q.setValueAtTime(5 + random(0,5), now); // Resonance

            noiseSource.connect(noiseFilter);
            noiseFilter.connect(noiseGain);
            noiseGain.connect(masterGain);
            noiseSource.start(now);
            noiseSource.stop(now + 0.12);
        }


        // --- Haptic Feedback --- (Unchanged Logic, adjusted constants)
        function triggerHaptic(type) { /* ... same ... */
            if ('vibrate' in navigator) {
                try {
                    if (type === 'click') {
                        navigator.vibrate(HAPTIC_CLICK);
                    } else if (type === 'major') {
                        // More complex pattern for major discharge
                         navigator.vibrate([HAPTIC_MAJOR_DISCHARGE * 0.6, 30, HAPTIC_MAJOR_DISCHARGE * 0.4]);
                    }
                } catch (e) {
                    // console.warn("Haptic feedback failed:", e); // Keep it quiet mostly
                }
            }
        }

        // --- Interaction Logic --- (More aggressive charging/effects)
        function processInteraction(currX, currY, isFastMovement) {
            let dx = currX - prevMouseX;
            let dy = currY - prevMouseY;

            // Slightly increased sensitivity / directness
            let moveScale = 0.006;
            rotX += dy * moveScale;
            rotY += dx * moveScale; // Corrected: was dx -> rotY

            // Apply reduced momentum during drag
            let momScale = 0.005;
            momX = dy * momScale;
            momY = dx * momScale;

            let distance = sqrt(dx * dx + dy * dy);
            distanceSinceLastNotch += distance;

            // More aggressive charging
            let chargeAddFactor = CHARGE_RATE_DRAG * (isFastMovement ? CHARGE_RATE_FAST_DRAG_MULT : 1);
            chargeLevel = min(MAX_CHARGE, chargeLevel + distance * chargeAddFactor);

            if (distanceSinceLastNotch > NOTCH_DISTANCE_DRAG) {
                let intensity = constrain(distance / 12, 0.1, 1.2); // Higher max intensity
                playClickSound(intensity);
                updateIntensityHistory(intensity);

                 // Higher probability and number of static discharges on fast drag
                let staticProb = map(intensity, 0.1, 1.2, 0.25, 0.9) * (chargeLevel / MAX_CHARGE);
                if (random() < staticProb) {
                    let numStatic = isFastMovement ? floor(random(1, 5)) : 1; // More sparks on fast move
                    for (let i = 0; i < numStatic; i++) {
                        // Stagger the static discharges slightly
                        setTimeout(() => createStaticDischarge(isFastMovement ? 1.2 : 1.0), random(i * 15));
                    }
                }

                let now = millis();
                // Higher chance of major discharge on fast drag
                if (isFastMovement && chargeLevel > 65 && now - lastBigDischargeTime > BIG_DISCHARGE_MIN_INTERVAL / 2.5 && random() < 0.12) {
                    createMajorDischarge();
                    playMajorDischargeSound();
                    lastBigDischargeTime = now;
                    chargeLevel *= 0.5; // Keep significant charge drain
                    intensityHistory = [];
                }
                distanceSinceLastNotch = 0;
            }

            prevMouseX = currX;
            prevMouseY = currY;
            lastInteractionTime = millis();
        }

        // --- Event Handlers --- (Minor changes for fast movement detection)
         function handleMouseDown(e) { /* ... same ... */
              isDragging = true; prevMouseX = e.clientX; prevMouseY = e.clientY;
             momX = 0; momY = 0; distanceSinceLastNotch = 0; intensityHistory = [];
             e.preventDefault();
         }
         function handleMouseMove(e) {
             if (!isDragging) return;
             // More sensitive fast movement check
             let isFast = abs(e.movementX) + abs(e.movementY) > 12;
             processInteraction(e.clientX, e.clientY, isFast);
         }
         function handleMouseUp() { /* ... same ... */ if (isDragging) { isDragging = false; } }
         function handleTouchStart(e) { /* ... same ... */
             if (e.touches.length === 1) {
                 isDragging = true; prevMouseX = e.touches[0].clientX; prevMouseY = e.touches[0].clientY;
                 momX = 0; momY = 0; distanceSinceLastNotch = 0; intensityHistory = [];
                 e.preventDefault();
             }
         }
        function handleTouchMove(e) {
             if (!isDragging || e.touches.length !== 1) return;
             let currentX = e.touches[0].clientX;
             let currentY = e.touches[0].clientY;
             let dx = currentX - prevMouseX;
             let dy = currentY - prevMouseY;
             // Adjusted fast movement threshold for touch
             let isFast = sqrt(dx * dx + dy * dy) > 8;
             processInteraction(currentX, currentY, isFast);
             e.preventDefault();
        }
         function handleTouchEnd(e) { /* ... same ... */ if (isDragging) { isDragging = false; } }
         function handleWheel(e) {
             e.preventDefault();
             let now = millis();
             // Reduced timeout allows quicker re-interaction via wheel
             if (now - lastInteractionTime > 20) {
                 let delta = e.deltaY !== 0 ? e.deltaY : e.deltaX;
                 // Increased sensitivity for wheel rotation/momentum
                 let rotationAmount = delta * 0.01;
                 let momentumAmount = delta * 0.004;
                  // Apply momentum more strongly
                 if (abs(e.deltaY) > abs(e.deltaX)) { rotY += rotationAmount; momX = momentumAmount; momY *= 0.3; } // Changed axis mapping and momentum reduction
                 else { rotX -= rotationAmount; momY = -momentumAmount; momX *= 0.3; } // Changed axis mapping and momentum reduction

                 let scrollIntensity = constrain(abs(delta) / 40, 0.1, 1.3); // Higher max intensity
                 let chargeToAdd = map(scrollIntensity, 0.1, 1.3, 3, 15); // More charge from scroll
                 chargeLevel = min(MAX_CHARGE, chargeLevel + chargeToAdd);

                 updateIntensityHistory(scrollIntensity);
                 playClickSound(scrollIntensity * 1.1); // Louder scroll clicks

                 // More static discharges from scroll
                 let numStatic = floor(map(scrollIntensity, 0.1, 1.3, 1, 6));
                 for (let i = 0; i < numStatic; i++) {
                     if (random() < 0.7) { setTimeout(() => createStaticDischarge(), random(i * 25)); }
                 }

                 // Higher chance of major discharge from intense scroll
                 if (scrollIntensity > 0.8 && chargeLevel > 60 && now - lastBigDischargeTime > BIG_DISCHARGE_MIN_INTERVAL / 1.5 && random() < 0.20) {
                    setTimeout(() => {
                        createMajorDischarge(); playMajorDischargeSound();
                        lastBigDischargeTime = now; chargeLevel *= 0.4; intensityHistory = [];
                     }, random(30, 100)); // Faster discharge trigger
                 }
                 lastInteractionTime = now;
             }
         }

        // --- Window Resize and Back Button ---
         function windowResized() {
             resizeCanvas(windowWidth, windowHeight);
             // Recalculate sphere radius and regenerate stars on resize
             wireframeSphere = createWireframeSphere(Math.min(windowWidth, windowHeight) * 0.3, SPHERE_DETAIL);
             generateStars();
         }
        function goBack() {
            // Attempt to go back in history first, then redirect
            if (window.history.length > 1) {
                window.history.back();
            } else {
                // Fallback if no history (e.g., opened in new tab)
                // Assumes index.html is in the same directory or parent. Adjust if needed.
                try { window.location.href = './index.html'; } catch (e) { console.log("Couldn't redirect");}
            }
        }

    </script>
</body>
</html>